'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.parseDocumentPath = parseDocumentPath;
exports.createDocumentPath = createDocumentPath;
exports.convertToDotNotationString = convertToDotNotationString;


/**
 * @public
 * Parse DocumentPath into an array of property names.
 */
function parseDocumentPath(docPath) {
  /*
   * This is workaround for negative lookbehind regular expression.
   * Some JS runtimes haven't implemented the feature determined by ES2018.
   * "$$$" is a temporary replacer of ".".
   */
  return docPath.split(/\\./).join('$$$').split(/[.[]/).map(function (attribute) {
    return attribute.charAt(attribute.length - 1) === ']' ? parseInt(attribute.slice(0, -1)) : unescapePathDelimiter(attribute.split('$$$').join('\\.'));
  });
}

/**
 * Create DocumentPath from arguments.
 */


function createDocumentPath() {
  for (var _len = arguments.length, attributes = Array(_len), _key = 0; _key < _len; _key++) {
    attributes[_key] = arguments[_key];
  }

  var joined = attributes.reduce(function (docPath, attr) {
    return typeof attr === 'string' ? docPath + '.' + escapePathDelimiter(attr) : docPath + '[' + attr.toString() + ']';
  }, '');
  return joined.charAt(0) === '.' ? joined.slice(1) : joined;
}

/**
 *
 */
function convertToDotNotationString(docPath) {
  return docPath.replace(/\[(\d{1,})\]/g, '.$1');
}

function escapePathDelimiter(attr) {
  return typeof attr === 'number' ? attr : attr.replace(/\./g, '\\.');
}

function unescapePathDelimiter(attr) {
  return typeof attr === 'number' ? attr : attr.replace(/\\\./, '.');
}